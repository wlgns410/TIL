# 34강 데이터베이스 설계

트랜잭션은 데이터베이스 설계의 방법이라고는 할 수 없지만, 시스템 개발 현장에서 많이 쓰인다.

## 1) 데이터베이스 설계
데이터베이스를 설계한다는 것은 데이터베이스의 스키마 내에 테이블, 인덱스, 뷰 등의
데이터베이스 객체를 정의하는 것을 말한다.

데이터베이스 설계의 주된 내용은 테이블의 이름이나 열, 자료형을 결정하는 것이다.
테이블 간의 관계를 생각하면서 여러 테이블을 정의하고 작성하게 된다. 단, 설계인 이상 테이블 정의에만 그치지 않는다.

- 논리명과 물리명
테이블을 설계할 때는 테이블 정의서나 설계도 등의 문서를 작성하는 경우가 많다.
CREATE TABLE에 지정하는 이름을 물리명이라 부른다. 또 하나는 논리명이라는 것으로 테이블의 설계상 이름에 해당한다.

물리명은 데이터베이스 시스템 규칙에 따라 길이에 제한이 있거나 공백문자를 사용할 수 없는 등의 제약이 따른다.
따라서 일상에서 사용하는 단어로는 이름을 지정하는 데 한계가 있다. 또한 전통적으로 알파벳을 사용해 이름을 지정한다.

물리명만으로는 의미가 전달되지 않는 경우가 많아 논리명이 필요해진다. 물리명의 경우 CREATE TABLE 명령으로 테이블을 작성할 때
사용하는 이름이라면, 논리명은 해당 테이블을 실제로 부를 때 사용하는 이름이다. 물리명은 잘못 정하면 변경하기 어렵지만
논리명은 언제든 바꿀 수 있다.

- 자료형
수치형을 문자열형으로 바꾸는 것은 문제가 되지 않지만 문자열형을 수치형으로 변환하는 경우에는 에러가 발생하기도 한다.
일반적으로는, 데이터베이스 시스템에서 데이터 정합성을 체크할 수 있다면 데이터베이스에 맡겨버리는 편이 가장 확실하고 편리하다.
이런 기능을 활용하는 대신 애플리케이션에서 따로 구현해 사용할 수도 있지만, 이런 경우 정합성이 맞지 않을 수 있으며
개발비용도 상승해 추천하지 않는다.

- 고정길이와 가변길이
문자열의 자료형에는 고정길이와 가변길이가 있습니다. 어느 쪽으로 지정할 것인지는 저장할 데이터를 고려해 결정합니다. 자리수가 이미
정해져 있는 경우에는 고정길이 문자열로 지정하는 편이 좋다. 데이터의 최대길이 역시 제조번호의 자릿수에 맞춰 정하면 된다.
한편, 자주 입력되지 않지만 입력되는 문자열의 길이의 변동폭이 클 경우에는 가변길이 문자열이 적합하다.

데이터베이스 열에 저장할 수 있는 크기는 의외로 작다. varchar 형으로 지정할 수 있는 최대 크기는 수천 바이트이다.
조금 큰 파일의 그대로 varchar 형의 열에 저장하면 쉽게 용량을 넘겨버린다. 이러한 경우에는 LOB 형을 사용한다. LOB는 Large Object
라는 뜻으로 큰 데이터를 다루는 자료형이지만 인덱스를 지정할 수 없다는 제약이 있다.

- 기본키
테이블을 작성할 때 기본키 제약을 거는 경우에는 주의가 필요하다. 테이블의 행에 유일성을 지정한다는 것은 대단히 중요하다.
하지만 기본키로 지정할 열이 생각나지 않는 경우도 많다. 이런 경우 자동증가 열을 사용해서 기본키로 지정하면 간단하게 해결할 수 있다.

자동증가 열은 insert 할 경우 번호를 자동으로 증가시켜 저장해주는 편리한 열이다. 데이터베이스 제품에 따라 다르지만, MySQL의 경우
열을 정의할 때 AUTO_INCREMENT를 지정하는 것으로 자동 증가 열이 된다. AUTO_INCREMENT로 지정한 열은 PRIMARY KEY 또는
UNIQUE로 유일성을 지정해야 한다. 아무 열이나 자동증가 열로 지정하지 않도록 주의해야한다.

- ER 다이어그램

![다운로드](https://user-images.githubusercontent.com/81137234/133868255-741b1bc4-4f3a-4a24-897b-90e3ba624441.jpeg)

테이블을 설계할 때 테이블 간의 관계를 명확히 하기 위해 설계도를 작성하는 경우가 있다.
ER 다이어그램은 이런 경우에 널리 쓰인다. ER의 E는 개체를 뜻하는 Entity의 약자이며 R은 Relationship의 약자이다.
즉, 개체 간의 관계를 표현한 것이다. ER 다이어그램의 관계는 관계형 데이터베이스의 릴레이션과 달리 릴레이션십을 가리킨다.

엔티티, 즉 개체는 테이블 또는 뷰를 말한다. ER 다이어그램에서 개체는 사각형으로 표기한다. 사각형의 상단에는 개체 이름을 적고
사각형 안에는 개체의 속성을 표기한다. 여기서 속성은 테이블의 열을 의미한다. 기본키가 되는 열부터 차례로 기술하며,
열 이름은 주로 논리명으로 표기한다.

개체와 개체가 서로 연결되는 경우에는 선으로 이어서 표현한다. 앞에서 결합을 설명할 때 작성했던 상품 테이블과 메이커 테이블은 메이커 코드를
매체로 연결된다.

연계를 표기할 때는 서로 몇 개의 데이터 행과 연관되는지, 즉 몇 대 몇의 관계를 가지는지를 숫자나 기호로 나타낼 수 있다.

![img](https://user-images.githubusercontent.com/81137234/133868275-6a2c54ff-f578-4b2d-9e88-a3e3539a2168.png)

> 일대일, 일대다, 다대다

---

<br>

# 35강 정규화

정규화란 데이터베이스의 테이블을 규정된 올바른 형태로 개선해나가는 것이다.
정규화는 데이터베이스 설계 단계에서 행해진다. 경우에 따라서 기존 시스템을 재검토할 때 정규화하는 경우도 있다.

## 1) 제1정규형

![21134B4557FEAE2D33](https://user-images.githubusercontent.com/81137234/133868301-30dc9af3-350a-48d2-9ccf-0473c4cbd59f.png)

정규화는 단계적으로 실시한다. 그 첫번째 단계가 제1 정규화로 이를 시행하면 제1 정규형 테이블을 만들 수 있다.
하나의 셀에 하나의 값만 저장할 수 있고, 반복되는 부분을 세로(행) 방향으로 늘려나가는 것이 제1정규화의 제1단계이다.

제1정규화에서는 중복을 제거하는 테이블의 분할도 이루어진다.
즉, 반복되는 부분을 찾아내서 테이블을 분할하고 기본키가 될 열을 작성할 수 있다.

## 2) 제2정규형
제2정규형에서는 데이터가 중복하는 부분을 찾아내어 테이블로 분할해 나간다. 이때 기본키에 의해 특정되는 열과 그렇지 않은 열로 나누는 것으로
정규화가 이루어진다.
부분 함수종속성을 찾아내서 테이블을 분할하는 것이 제2정규화이다.
* 함수종속성이란 키 값을 이용해 데이터를 특정지을 수 있는 것을 말한다.

## 3) 제3정규형
중복하는 부분을 찾아내어 테이블을 분할하는 수법이다. 제2정규화에서는 기본키에 중복이 없는지 조사했다.
제3정규형은 기본키 이외의 부분에서 중복이 없는지를 조사한다.

많은 정규형 단계가 있지만 대부분의 시스템에서는 제3정규형까지의 정규화를 채택한다고 한다.

정규화를 통해 테이블을 분할해 나가며, 분할할 때는 서로 결합할 수 있도록 기본키를 추가해 분할한다.
테이블 간의 연계는 ER 다이어그램으로 표현하면 알기 쉽다.

## 4) 정규화의 목적

정규화에서는 중복하거나 반복되는 부분을 찾아내서 테이블을 분할하고 기본키를 작성해 사용하는 것을 기본 개념으로 삼는다.
이는 `하나의 데이터는 한 곳에 있어야 한다`는 규칙에 근거한다.

하나의 데이터가 반드시 한 곳에만 저장되어 있다면 데이터를 변경하더라도 한 곳만 변경하는 것으로 끝낼 수 있다.
반면 정규화되지 않은 경우에는 여기저기 중복해서 저장된 데이터를 검색하고 일일이 변경해야 한다.
이것은 매우 번거로운 작업이다. 또한 인덱스가 지정된 열의 데이터가 변경되는 경우에는 인덱스도 재구축해야 한다.

하지만 기본키는 분할한 테이블끼리 연계하기 위해 작성한, 이른바 내부적인 데이터이므로 변경될 일이 거의 없다.
따라서 정규화를 통해 테이블에 대한 인덱스의 재구축을 억제할 수 있다.


---

<br>

# 36강 트랜잭션

데이터베이스는 트랜잭션이라는 기능을 제공한다. insert나 update 명령으로 데이터를 추가, 갱신할 때도 트랜잭션을 이용하지만,
자동 커밋이라는 기능 때문에 의식하지 않아도 됐었다.

## 1) 트랜잭션

- 발주처리 예시
만약 주문이 발생했을 때, 주문 번호를 지정해야한다. 이때 기존 주문과 구분되는 주문번호를 발행하는 처리가 필요하다.
자동 증가를 사용하면 자동적으로 번호가 부여되지만, 그렇지 않은 경우에는 번호 중 가장 큰 값을 select 명령으로 가져와
그 값에 1을 더하는 처리가 필요하다. 최대값은 max로도 검색할 수 있으며 max + 1로 처리할 수도 있다.

번호를 발행 받으면 해당 번호를 키로 삼아 Insert가 이루어진다. 주문 테이블에는 insert 한 번, 주문 상품 테이블에는
주문된 상품 수만큼 insert 명령이 실행된다. 중요한 것은 복수의 테이블에 Insert되므로 실행되는 명령은 최소 2번이라는 점이다.

여기서 insert 명령이 특정 원인으로 인해 에어가 발생한 경우를 가정한다.
트랜잭션 기능을 사용하지 않을 때는 문제없이 실행된 insert 명령을 실행 전으로 되돌릴 수 없으므로 따로 delete 명령을 실행해
지워야한다. 만약 3번의 insert가 있었는데, 3번째 insert가 오류가 났다면 앞의 2개 insert도 delete로 삭제해야한다는 것이다.

- 롤백과 커밋
몇 단계로 처리를 나누어 SQL 명령을 실행하는 경우에 트랜잭션을 자주 사용한다. 트랜잭션을 사용해서 데이터를 추가한다면
에러가 발생해도 트랜잭션을 롤백해서 종료할 수 있다. 롤백하면 트랜잭션 내에서 행해진 모든 변경사항을 없었던 것으로 할 수 있다.
아무런 에러가 발생하지 않는다면 변경사항을 적용하고 트랜잭션을 종료하는데, 이때 커밋을 사용한다.

- 자동커밋
트랜잭션을 사용해서 데이터를 추가할 때는 자동커밋을 꺼야한다. MySQL 클라이언트에서 명령을 실행할 때는 자동커밋이 켜져있는 상태이다.
insert, delete, update가 처리될 때마다 트랜잭션은 암묵적으로 자동커밋 상태로 되어 있다. 자동커밋울 끄기 위해서는 명시적으로
트랜잭션의 시작을 선언할 필요가 있다. 트랜잭션을 시작할 때는 `start transaction` 명령을 사용한다.

트랜잭션을 종료하기 위해서는 변경된 내용을 적용한 후에 종료하는 커밋과 적용하지 않고 종료하는 롤백의 방식이 있다.
커밋할 때에는 `commit` 명령을 사용한다.
롤백할 때는 `rollback` 명령을 사용한다.

트랜잭션 내에서 실행된 SQL 명령은 임시 데이터 영역에서 수행되다가, commit 명령을 내리면 임시 데이터 영역에서 정식 데이터
영역으로 변경이 적용된다고 생각하면 된다. rollback 명령을 내리면 임시 데이터 영역에서의 처리가 삭제된다.
트랜잭션은 commit을 이용해 종료를 한다.

트랜잭션을 시작해서 SQL 명령을 실행하고 commit 또는 rollback 명령으로 트랜잭션을 종료하는 일련의 처리방법을 트랜잭션을 걸어서
실행한다 또는 트랜잭션 내에서 실행한다고 말한다.

## 2) 트랜잭션 사용법
하나의 명령에 트랜잭션을 걸어 실행하는 것은 의미가 없다.
트랜잭션 내에서 실행하는 복수의 SQL 명령은 세트 단위로 유효/무효가 된다.
세트로 실행하고 싶은 SQL 명령을 트랜잭션에서 하나로 묶어 실행하는 것이다. 또 rollback은 에러가
발생한 경우 변경사항이 적용되지 않도록 하는 목적으로 주로 사용하지만, 에러가 발생하지 않아도 rollback을 하면
변경한 내용은 파기된다. 반대로 에러가 발생하더라도 commit을 하면 문제없이 실행된 SQL 명령의 변경사항은
데이터베이스에 그대로 반영된다.

> 세트로 실행하고 싶은 SQL 명령은 트랜잭션 내에서 실행한다.

트랜잭션을 시작할 때 사용하는 명령은 `start transaction`인데, 이것은 MySQL 명령어이다.
`begin transaction`은 PostgreSQL, SQL server에서 사용하는 명령어이다.

자동커밋은 클라이언트 툴의 기능이다. 미들웨어도 데이터베이스 접속 시 대개 자동커밋을 한다. 한편, 데이터베이스 서버에서는
언제나 트랜잭션을 걸 수 있는 상태로 SQL 명령이 실행된다. 트랜잭션을 사용할 경우 접속형태나 클라이언트의 자동커밋 사용 여부 등,
트랜잭션 관련 기능을 파악해 둘 필요가 있다.

delete 명령은 삭제 여부에 관해 사용자에게 확인하지 않는다. delete 명령을 트랜잭션 내에서 실행하는 경우에는 rollback으로
삭제를 취소할 수 있다. 단, 자동커밋으로 되어있는 경우에는 주의를 해야한다.
rollback으로 취소할 수 있는 것은 트랜잭션 내에서 실행했을 경우이다.

<br>