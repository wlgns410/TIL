# 20강 행 개수 구하기 - count

## 1) COUNT

SQL은 데이터베이스라 불리는 데이터 집합을 다루는 언어이다.
일반적인 함수는 인수로 하나의 값을 지정하는데 비해 집계함수는 인수로 집합을 지정한다. 이 때문에 집합함수라고 불린다.
즉, 집합을 특정 방법으로 계산하여 그 결과를 반환한다.

<img width="257" alt="스크린샷 2021-09-15 오전 9 59 40" src="https://user-images.githubusercontent.com/81137234/133353393-44bab5b5-b88b-4c21-b924-b98b005dd84b.png">

test 테이블에는 2개의 행이 있으므로 count의 결과값은 2이다. 인수로 `*`이 지정되어 있는데 이는 SELECT 구에서 모든 열을 나타낼 때 사용한다.
count 집계함수에서 모든 열 = 테이블 전체라는 의미로 사용된디. 즉, count는 인수로 지정된 집합의 개수를 계산하는 것이다.

집계함수는 집합으로부터 하나의 값을 반환한다. 이렇게 집합으로부터 하나의 값을 계산하는 것을 `집계`라고 한다. 이러한 이유로 집계함수를 SELECT 구에 사용하면 WHERE 구의 유무와 관계없이 하나의 행을 반환한다.

<img width="361" alt="스크린샷 2021-09-15 오전 10 05 06" src="https://user-images.githubusercontent.com/81137234/133353689-6effb515-f4c5-4981-848f-6783f9dc5064.png">

SELECT 구는 WHERE 구보다 나중에 내부적으로 처리된다. 따라서 WHERE 구로 조건을 지정하면 테이블 전체가 아닌, 검색된 행이 COUNT로 넘겨진다. 즉, WHERE 구의 조건에 맞는 행의 개수를 구할 수 있다.

## 2) 집계함수와 NULL 값

*을 인수로 사용할 수 있는 것은 COUNT 함수뿐이다. 다른 집계함수에서는 열명이나 식을 인수로 지정한다. 집계함수에서는 NULL 값이 있을 경우 이를 제외하고 처리한다.

<img width="343" alt="스크린샷 2021-09-15 오전 10 08 29" src="https://user-images.githubusercontent.com/81137234/133354016-3b73b72f-7a48-492f-8016-8c7150b24fd2.png">

count(*)의 경우 모든 열의 행수를 카운트하기 때문에 NULL 값이 있어도 해당 정보가 무시되지 않으나, 일반 열을 count할 경우에는 NULL 값을 무시합니다.

## 3) distinct로 중복 제거

데이터가 서로 중복되지 않는 경우에는 유일한 값을 가지거나 값이 중복되지 않는다.

<img width="301" alt="스크린샷 2021-09-15 오전 10 15 46" src="https://user-images.githubusercontent.com/81137234/133354480-b180e681-c4e2-44a5-97b9-844d160b89ae.png">

select 구에서 distinct를 지정하면 중복된 데이터를 제외한 결과를 클라이언트로 반환한다. 중복 여부는 select 구에서 지정된 모든 열을 비교해 판단한다.
select 구에서 지정하는 ALL 또는 distinct는 중복 값을 제거할 것인지 설정하느 스위치와 같은 역할이다. 이때 ALL 과 distinct 중 어느 것도 지정하지 않은 경우에는 중복된 값은 제거되지 않는다. 즉, 생략할 경우에는 ALL로 간주한다.

## 4) 집계함수에서 distinct

WHERE 구에서는 검색할 조건을 지정하는 것만 가능하다. 중복된 값인지 아닌지를 알아보는 함수도 없다.
집계함수의 인수 distinct는 집계함수의 인수에 수식자로 지정할 수 있다. distinct를 이용해 집합에서 중복을 제거한 뒤 count로 개수를 구해보자.

<img width="386" alt="스크린샷 2021-09-15 오전 10 29 02" src="https://user-images.githubusercontent.com/81137234/133355514-035fb29b-3e68-45e4-9e7d-27b541dbc01c.png">

SELECT 구에서의 중복삭제와 마찬가지로 DISTINCT가 아닌 ALL을 지정하면 집합 전부가 집계함수에 주어진다. ALL을 생략해도 결과는 같다. 이때 DISTINCT와 ALL은 인수가 아니므로 콤마를 붙이지 않는다.

---

<br>

# 21강 count 이외의 집계함수

## 1) SUM으로 합계 구하기

<img width="302" alt="스크린샷 2021-09-15 오전 10 34 58" src="https://user-images.githubusercontent.com/81137234/133356008-ba3a1c34-471e-4dc1-a600-4b83b2ea5e3e.png">

SUM 집계함수에 지정되는 집합은 수치형 뿐이다. 문자열형이나 날짜시간형의 집합에서 합계를 구할 수 없다. name 열은 문자형이므로 SUM(name)과 같이 지정할 수 없다. 한편, SUM 함수도 COUNT와 마찬가지로 NULL 값을 무시한다.

## 2) AVG로 평균내기

* sum / count = avg

SUM과 COUNT를 이용하지 않더라도 AVG라는 집계함수를 통해 평균값을 간단하게 구할 수 있다. AVG는 SUM과 마찬가지로 수치형만 가능하다.

<img width="371" alt="스크린샷 2021-09-15 오전 10 37 59" src="https://user-images.githubusercontent.com/81137234/133356244-4316847d-dfef-4bb9-9b01-cc2f6701f6ba.png">

AVG도 NULL값을 무시한다. 만약 NULL을 0으로 간주해서 평균을 내고 싶다면 CASE를 사용해 NULL을 0으로 변환한 뒤에 AVG 함수로 계산한다.

* select avg(case when 열명 IS NULL then 0 else 열명 end) from 테이블명;

## 3) MIN, MAX로 최솟값, 최댓값 구하기

<img width="494" alt="스크린샷 2021-09-15 오전 10 44 45" src="https://user-images.githubusercontent.com/81137234/133356807-e7d96e22-4322-4b26-b644-3ee9bb8e8bea.png">

이 함수들은 문자형과 날짜시간형에도 사용가능하다. 다만 NULL 값은 무시한다.

---

<br>

# 22강 그룹화 

## 1) group by

GROUP BY 구를 사용해 집계함수로 넘겨줄 집합을 그룹으로 나눌 수 있다.

<img width="314" alt="스크린샷 2021-09-15 오전 10 47 03" src="https://user-images.githubusercontent.com/81137234/133356998-46bfa29e-00a0-4ef1-be4d-33980b45017d.png">

name 열에서 같은 값을 가진 행끼리 한데 묶어 그룹화한 집합을 집계함수로 넘겨줄 수 있다. 그룹으로 나눌 때 사용하며, 복수로도 지정 가능하다.
이렇게 하면 distinct를 지정했을 때와 같은 결과가 나온다. group by 구에 열을 지정하여 그룹화하면 지정된 열의 값이 같은 행이 하나의 그룹으로 묶인다. 또한 중복을 제거하는 효과도 있다.

group by는 집계함수와 같이 사용할 때 의미가 있다. group by 구로 그룹화된 각각의 그룹이 하나의 집합으로서 집계함수의 인수로 넘겨지기 때문이다.

<img width="470" alt="스크린샷 2021-09-15 오전 10 51 36" src="https://user-images.githubusercontent.com/81137234/133357388-79d30658-1374-4a86-9909-23221ba90ce9.png">

## 2) having

<img width="567" alt="스크린샷 2021-09-15 오전 10 54 43" src="https://user-images.githubusercontent.com/81137234/133357638-4ea030bf-c752-4e90-9acf-5028487a16b1.png">

name 열을 그룹화해 행 개수가 하나만 존재하는 그룹을 검색하려고 했지만 에러가 발생한다. 이유는 group by와 where 구의 내부처리 순서 때문이다. where 구로 행을 검색하는 처리가 group by로 그룹화하는 처리보다 순서상 앞에 있기 때문이다. select 구에서 지정한 별명을 where 구에서 사용할 수 없었던 것과 같은 이유이다. 그룹화가 필요한 집계함수는 where 구에서 지정할 수 없다.

<img width="570" alt="스크린샷 2021-09-15 오전 10 57 20" src="https://user-images.githubusercontent.com/81137234/133357859-edfa7240-7e0a-42d7-acae-21e016b4b208.png">

그룹화보다도 나중에 처리되는 group by 구에서는 문제없이 집계함수를 사용할 수 있다. 즉, order by count(name)과 같이 지정할 수 있다.

* where 구 -> group by 구 -> having 구 -> select 구 -> order by 구

<img width="548" alt="스크린샷 2021-09-15 오전 11 01 05" src="https://user-images.githubusercontent.com/81137234/133358200-1a313a17-f6a2-4264-9c6c-a1a292a03c3e.png">

다만 select 구보다도 먼저 처리되므로 별명을 사용할 수 없다. 예를 들어 count(name)에 sk 라는 별명을 붙이면, order by 구에서는 사용할 수 있지만, group by, having 구에서는 사용할 수 없어야하지만, MySQL에서는 실행 가능하다.

## 3) 복수 열의 그룹화

<img width="598" alt="스크린샷 2021-09-15 오전 11 02 27" src="https://user-images.githubusercontent.com/81137234/133358286-82a29dfe-09ac-40a7-a8a4-5efeacfde619.png">

group by를 사용할 때 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 select 구를 기술해서는 안된다.
클라이언트로 반환되는 결과는 그룹당 하나의 행이 된다. 하지만 name 열 값이 A인 그룹의 date 열 값은 여러개이다. 이때 그룹마다 하나의 값만 반환해야하므로 에러가 발생한다.

<img width="467" alt="스크린샷 2021-09-15 오전 11 05 08" src="https://user-images.githubusercontent.com/81137234/133358476-ce0ab7eb-d32b-42db-ab61-db347f990a9f.png">

이때 집계함수를 사용하면 집합은 하나의 값으로 계산되므로 그룹마다 하나의 행을 출력할 수 있다.

<img width="409" alt="스크린샷 2021-09-15 오전 11 06 20" src="https://user-images.githubusercontent.com/81137234/133358578-656d6eef-bc9f-4cc4-99c9-b0afe781f00b.png">

아니면 group by에서 지정한 열이라면 select 구에서 그대로 지정할 수 있다.

## 4) 결과값 정렬

<img width="573" alt="스크린샷 2021-09-15 오전 11 09 21" src="https://user-images.githubusercontent.com/81137234/133358808-ddae7567-d4f4-4a4b-9fe5-bd040b4035fd.png">

group by로 그룹화해도 실행결과 순서를 정렬할 수는 없다. 데이터베이스 내부 처리에서 같은 값을 그룹으로 나누는 과정에서 순서가 서로 바뀌는 부작용이 일어날 수 있기 때문이다. 이때는 order by 구를 사용해 정렬할 수 있다. group by 사용 후 order by를 연달아 사용할 수도 있다.

* DESC 내림차순(큰 값 -> 작은 값), ASC 오름차순(작은 값 -> 큰 값)

---

<br>

# 23강 서브쿼리

서브쿼리는 select 명령에 의한 데이터 질의로 상부가 아닌 하부의 부수적인 질의를 의미한다.

select 구, from 구, where 구 등 select 명령의 각 구를 기술할 수도 있다.
특히, where 구에서 주로 사용된다.

## 1) delect의 where 구에서 서브쿼리 사용하기

<img width="308" alt="스크린샷 2021-09-15 오전 11 16 41" src="https://user-images.githubusercontent.com/81137234/133359350-48668872-7128-4dbc-9d7c-0f429fa6c5c9.png">

행의 값을 알고있다면 쉽게 삭제할 수 있다. 행 중 가장 작은 값을 삭제하고 싶다면 select로 검색이 필요하다.

* delete from 테이블명 where 열이름 = (select min(열이름) from 테이블명);
하지만 이건 MySQL에서는 실행이 불가하다.
> You can't specify target table 'test' for update in FROM clause

<img width="586" alt="스크린샷 2021-09-15 오전 11 27 24" src="https://user-images.githubusercontent.com/81137234/133360317-da1df721-669a-46ce-80dc-d88177e67d3e.png">

다음과 같은 에러가 발생하는데, 데이터를 추가하거나 갱신할 경우 동일한 테이블을 서브쿼리에서 사용할 수 없도록 되어있기 때문이다. 에러를 발생하지 않고 실행하려면 인라인 뷰로 임시 테이블을 만들도록 처리해야한다. 하지만 모든 행 값이 삭제될 수 있다.

<img width="321" alt="스크린샷 2021-09-15 오후 12 27 40" src="https://user-images.githubusercontent.com/81137234/133365799-1508b28d-0ffc-48e6-8d0a-6c6151cb065a.png">

mysql 클라이언트에 한해 @id가 변수가 되고 set이 변수에 대입하는 명령을 입력할 수 있다.

## 2) 스칼라 값

<img width="239" alt="스크린샷 2021-09-15 오후 12 29 09" src="https://user-images.githubusercontent.com/81137234/133365900-40641c12-093f-46b6-ae34-74318468f949.png">

하나의 값을 반환하는 패턴이다. 단일 값으로도 통용되지만 데이터베이스업계에서는 스칼라 값이라고 많이 부른다.

<img width="206" alt="스크린샷 2021-09-15 오후 12 29 56" src="https://user-images.githubusercontent.com/81137234/133365944-d3b0d194-5186-41f1-83ee-bd0f9727cce7.png">

복수의 행이 반환되지만 열은 하나인 패턴

<img width="315" alt="스크린샷 2021-09-15 오후 12 30 50" src="https://user-images.githubusercontent.com/81137234/133366023-e65fbe45-7494-44ae-867a-3140d2a609b8.png">

하나의 행이 반환되지만 열이 복수인 패턴

<img width="240" alt="스크린샷 2021-09-15 오후 12 31 33" src="https://user-images.githubusercontent.com/81137234/133366065-34e60cdb-91bf-4e41-ac3c-6783aa786940.png">

복수의 행, 복수의 열이 반환되는 패턴

SELECT 구에서 하나의 열을 지정하고 group by를 지정하지 않은 채 집계 함수를 사용하면 결과는 단일한 값이 된다. 만약 group by로 그룹화를 하면 몇 가지의 그룹으로 나뉘어져 버릴 가능성이 있기 때문에 결과적으로 단일한 값이 반환되지 않을 수 있다. 또한 where 조건으로 하나의 행만 검색할 수 있다면 단일 값이 되므로 스칼라 값을 반환하는 select 명령이 된다.
즉, where 구에서는 스칼라 값을 반환하는 서브쿼리는 `=` 연산자로 비교할 수 있다.
select 구에서 다른 열을 지정하거나 group by를 지정하면 바로 에러가 발생한다.

스칼라 값을 반환하는 서브쿼리를 특별히 스칼라 서브쿼리라 부른다. 앞서 having 구를 설명할 때 집계함수는 where 구에 사용할 수 있으므로 집계함수를 사용해 집계한 결과를 조건식으로 사용할 수 있다.

비슷한 문제로 group by에서 지정한 열 이외의 열을 select 구에 지정하면 에러가 되는 것도 있다.

## 3) select 구에서 서브쿼리 사용하기

서브쿼리는 하나의 항목으로 취급한다. 단, 문법적으로 문제없지만 실행하면 에러가 발생하는 경우가 자주 있다. 이는 스칼라 값의 반환 여부에 따라 생기는 현상으로 서브쿼리를 사용할 때는 스칼라 서브쿼리로 되어있는 지 확인해야한다.

select 구에서 서브쿼리를 지정할 때는 스칼라 서브쿼리가 필요하다.

<img width="588" alt="스크린샷 2021-09-15 오후 12 41 16" src="https://user-images.githubusercontent.com/81137234/133366943-2bd26140-6539-47c6-bdaa-97bad4c5dd10.png">

test 테이블의 행 개수를  sq1, sq2로 나눴습니다. 서브쿼리가 아닌 상부의 select 명령에는 from 구가 없습니다. MySQL 등에서는 from 구를 생략할 수 있다. 

## 4) SET 구에서 서브쿼리 사용하기

set 구에서 서브쿼리를 사용할 경우에도 스칼라 값을 반환하도록 스칼라 서브쿼리를 지정해야한다.

> update 테이블명 set 열명 = (select max(열명) from 테이블명);

실질적으로 사용하지 않는 update 명령어이다. update 명령을 실행하면 열 값이 모두 열의 최댓값으로 갱신된다. 이 경우 서브쿼리는 상부의 update 명령과 관련이 있는 조건식으로 지정하지 않으면 의미가 없다.

## 5) from 구에서 서브쿼리 사용하기

select 명령안에 select 명령이 들어있는 듯 보인다. 이를 `nested 구조`(중첩구조, 내포구조)라고 부른다. `sq`는 테이블의 별명으로 sub_query`의 이니셜이다. 마찬가지로 from 구에서는 테이블이나 서브쿼리에 별명을 붙일 수 있다.

서브쿼리에는 이렇다 할 이름이 붙여져 있지 않다. 별명을 붙이는 것으로 비로소 서브쿼리의 이름을 지정한다. 이 때도 select 구에서 별명을 붙일 때처럼 `as` 키워드를 사용해 지정한다.

<img width="353" alt="스크린샷 2021-09-15 오후 12 49 50" src="https://user-images.githubusercontent.com/81137234/133367685-209feb66-d509-4cac-9b1f-2bc1042d3867.png">

<img width="458" alt="스크린샷 2021-09-15 오후 12 50 54" src="https://user-images.githubusercontent.com/81137234/133367775-4b0dae77-7255-4720-80cf-7814c1c79a25.png">

중첩구조는 몇 단계로든 구성할 수 있다. 다음과 같이 3단계 구성해도 된다.

## 6) insert 명령과 서브쿼리

<img width="589" alt="스크린샷 2021-09-15 오후 12 54 17" src="https://user-images.githubusercontent.com/81137234/133368079-6e16b6f4-2b2a-4328-862f-57b888691b84.png">

insert 명령과 서브쿼리를 조합해 사용할 수 있다. insert 명령에는 values 구의 일부로 서브쿼리를 사용하는 경우와 values 구 대신 select 명령을 사용하는 두 가지 방법이 있다. 먼저 values 구의 값으로 서브쿼리를 사용할 때 서브쿼리는 스칼라 서브쿼리로 지정할 필요가 있다.
1행이 없으면 오류가 나올 수 있지만 나머지 행은 제대로 출력된다.

<img width="481" alt="스크린샷 2021-09-15 오후 12 56 34" src="https://user-images.githubusercontent.com/81137234/133368258-326e1f83-2cc4-4d2b-9e8a-b911508d8edd.png">

select 명령을 사용하는 것은 괄호를 붙이지 않는 방법으로 `insert select` 으로 불리는 명령이다. 이 때 select가 반환하는 값이 꼭 스칼라일 필요는 없다. select가 반환하는 열 수와 자료형이 insert할 테이블과 일치하기만 하면 된다.

> insert into 테이블명1 select * from 테이블명2;
열 구성이 똑같은 테이블 사이에서는 insert select 명령으로 행을 복사할 수 있다.

---

<br>

# 24강 상관 서브쿼리

상관서브쿼리를 사용해 `exists` 술어로 조합시켜서 서브쿼리를 사용할 수 있다.

행이 존재하지 않은 상태가 참이 될 때는 `not exists`를 사용한다.

상관 서브쿼리에서는 부모 명령과 연관되어 처리되기 때문에 서브쿼리 부분만을 떼어내어 실행시킬 수 없다. 

2개 이상의 테이블을 사용해 조회할 때 `where id=id`라고 조건을 지정하면 제대로 동작하지 않는다. 열이 애매하다는 에러가 발생한다. 하지만 `테이블명.열명`으로 이름 붙이면 가능하다.

<img width="341" alt="스크린샷 2021-09-15 오후 1 13 25" src="https://user-images.githubusercontent.com/81137234/133369544-98b77601-57b2-40ad-a74a-e29fd16df66d.png">

`in`에서는 오른쪽에 집합을 지정한다. 왼쪽에 지정된 값과 같은 값이 집합 안에 존재하면 참을 반환한다. 집합은 상수 리스트를 괄호로 묶어 기술한다.

<img width="465" alt="스크린샷 2021-09-15 오후 1 14 49" src="https://user-images.githubusercontent.com/81137234/133369635-dc210f49-a173-480b-81d4-cda527502786.png">

집합 부분은 서브쿼리로도 지정할 수 있다. 이 경우 서브쿼리는 스칼라 서브쿼리가 될 필요가 없다. in은 집합 안에 값이 포함되어 있으면 참이 된다.

* in을 사용해도 NULL 값을 비교할 수 없다. IS NULL을 사용해 비교해야한다.
* NOT IN의 경우 집합 안에 NULL이 있으면 왼쪽 값이 집합 안에 포함되어 있지 않아도 참을 반환하지 않고 UNKNOWN이 된다.

<br>