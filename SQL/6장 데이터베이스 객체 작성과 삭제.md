# 25강 데이터베이스 객체

## 1) 데이터베이스 객체란
테이블, 뷰, 인덱스 등 데이터베이스 내에 정의하는 모든 것을 일컫는 말
객체는 데이터베이스 내에 실체를 가지는 어떤 것, 객체의 종류에 따라 데이터베이스에 저장되는 내용도 달라진다. 테이블의 경우 행과 열이 저장된다. select, insert는 클라이언트에서 객체를 조작하는 SQL 명령이다. 데이터베이스 내에 존재하는 것이 아니므로 객체가 아니다.

객체는 이름을 가진다. 데이터베이스 내에서 객체를 작성할 때는 이름이 겹치면 안된다.
객체 이외에도 테이블의 열 또한 이름을 가진다.

* 명명규칙
- 기존 이름이나 예약어와 중복하지 않는다.
- 숫자로 시작할 수 없다
- 언더스코어 이외의 기호는 사용할 수 없다.
- 한글을 사용할 때는 더블쿼트로 둘러싼다.
- 시스템이 허용하는 길이를 초과하지 않는다.

## 2) 스키마
데이터베이스 객체는 스키마라는 그릇에 담긴다. 따라서 객체의 이름이 같아도 스키마가 서로 다르면 상관없다. 이와 같은 특징 때문에 데이터베이스 객체는 스키마 객체라고 불린다. 실제로 데이터베이스에 테이블을 작성해서 구축해나가는 작업을 스키마 설계라고 부른다. 이때 스키마는 SQL 명령의 DDL을 이용하여 정의한다.

데이터 테이블 안에는 열을 정의할 수 있고 스키마 안에는 테이블을 정의할 수 있다. 각각의 그릇 안에는 열을 정의할 수 있고 스키마 안에는 테이블을 정의할 수 있다. 그릇 안에서는 중복되지 않도록 한다. 이처럼 이름이 충돌되지 않도록 기능하는 그릇을 `네임스페이스`라고 한다.

--

<br>

# 26강 테이블 작성, 삭제, 변경

## 1) 테이블 작성

DDL은 CREATE, DROP, ALTER로 명령을 합니다.

<img width="407" alt="스크린샷 2021-09-16 오전 11 10 59" src="https://user-images.githubusercontent.com/81137234/133537928-bce6db86-ff8b-4b23-aa4c-9723e9428d39.png">

CREATE Table 명령으로 테이블의 이름을 지정한다.
테이블 명 뒤에는 괄호로 묶여 열을 정의한다. char, varchar 같은 문자열형을 지정할 때는 최대길이를 괄호로 묶어줘야한다.
기본값을 설정할 때는 default로 지정하되 자료형에 맞는 리터럴로 기술한다. 또한 기본값은 생략할 수 있다.
마지막으로 열이 NULL을 허용할 것인지 지정한다. NULL을 명시적으로 지정하거나 생략했을 경우는 NULL을 허용한다. 한편 NOT NULL이라고 지정하면 제약이 걸리면서 NULL이 허용되지 않는다.

## 2) 테이블 삭제

<img width="296" alt="스크린샷 2021-09-16 오전 11 12 47" src="https://user-images.githubusercontent.com/81137234/133538073-353dd6af-ec23-40c3-9854-f17c2ec80d42.png">

테이블을 삭제할 때 확인을 요구하지않으므로 주의해야한다.

- 데이터 행 삭제
drop table은 데이터베이스에서 테이블을 삭제한다. 이때 테이블에서 저장된 데이터도 함께 삭제된다. 한편 테이블 정의는 그대로 둔 채 데이터만 삭제할 때는 delete 명령을 사용한다. delete 명령에 where 조건을 지정하지 않으면 테이블의 모든 행을 삭제할 수 있다.

delete 명령은 행 단위로 여러 가지 내부처리가 일어나므로 삭제할 행이 많으면 처리속도가 상당히 늦어진다. 이런 경우에는 DDL로 분류된 `truncate table` 명령을 사용한다. 삭제할 행을 지정할 수 없고 where 구를 지정할 수도 없지만, 모든 행을 삭제해야 할때 빠른 속도로 삭제할 수 있다.

## 3) 테이블 변경

ALTER TABLE 명령을 사용하면 테이블에 저장되어 있는 데이터는 그대로 남긴 채 구성만 변경할 수 있습니다. ALTER TABLE로 할 수 있는 일은 크게 다음과 같이 두 가지로 분류할 수 있다.

- 열 추가, 삭제, 변경
<img width="398" alt="스크린샷 2021-09-16 오전 11 21 03" src="https://user-images.githubusercontent.com/81137234/133538822-7bf8a35b-c37e-44e3-99ce-89590f7f1c6c.png">

ALTER TABLE ADD로 열을 추가할 때, 기존 데이터행이 존재하면 추가한 열의 값이 모두 NULL이 된다. NOT NULL 제약을 붙인 열을 추가하고 싶다면 먼저 NOT NULL로 제약을 건 뒤에 NULL 이외의 값으로 기본값을 지정할 필요가 있다.

<img width="401" alt="스크린샷 2021-09-16 오전 11 23 26" src="https://user-images.githubusercontent.com/81137234/133539046-593a60df-5a73-4efc-baec-45e65e49682c.png">

기존의 데이터 행이 존재하는 경우, 속성 변경에 따라 데이터 역시 변환된다. 만약 자료형이 변경되면 테이블에 들어간 데이터의 자료형도 바뀐다. 처리과정에서 에러가 발생하면 ALTER TABLE 명령은 실행하지 않는다.

<img width="406" alt="스크린샷 2021-09-16 오전 11 25 49" src="https://user-images.githubusercontent.com/81137234/133539287-88b03e65-7a4e-45f7-b897-e9a88bbc6581.png">

열 이름을 변경할 때는 modify가 아닌 change를 사용한다. change를 사용한다. change는 열 이름뿐만 아니라 열 속성도 변경할 수 있다.

<img width="390" alt="스크린샷 2021-09-16 오전 11 27 49" src="https://user-images.githubusercontent.com/81137234/133539475-69b37e9a-f4d0-47bb-965c-097a3abba7ce.png">

alter table로 열을 삭제할 때는 drop 하부명령을 사용한다.


## 4) alter table로 테이블 관리

<img width="396" alt="스크린샷 2021-09-16 오전 11 36 40" src="https://user-images.githubusercontent.com/81137234/133540217-54d6f605-45a4-47c8-a0ea-af3f5d982759.png">

한 자리로 충분했던 용량이 부족해질 수  있다. 열의 자료형만 변경해 대응할 수 있다.
반대로 줄이고 싶은 경우도 있는데, 기존의 행에 존재하는 데이터의 길이보다 작게 지정할 수 없다. 작게 지정하면 저장된 데이터의 일부가 잘려나가므로 에러가 발생한다. 또한 열의 최대길이를 줄였다고 해서 실제 저장공간이 늘어나는 경우도 적다. 일반적으로 최대길이를 늘리는 경우는 많지만 줄이는 경우는 적다.

<img width="402" alt="스크린샷 2021-09-16 오전 11 37 11" src="https://user-images.githubusercontent.com/81137234/133540269-d7132792-6753-44c4-a229-110a29a8ac21.png">

열을 추가하는 것은 테이블의 정의가 바뀌는 일인 만큼 꽤 영향을 많이 준다, 변경한 테이블에 행을 추가하는 insert 명령은 확인을 해야한다. 열을 추가하면 해당 열에 대해 데이터 값을 지정해야하기 때문이다. 만약 기존 시스템의 insert 명령에서 열 지정이 생략되어 있다면, 열을 추가한 후 그대로 실행했을 때 열의 개수가 맞지 않아 에러가 발생한다.

---

<br>

# 27강 제약

테이블 간에는 부모 자식과 같은 관계를 가지며 정합성을 유지한다. 자식 테이블 측에서는 외부키(FK)를 지정해 부모 테이블을 참조한다. 부모 테이블에서 참조될 열은 반드시 유일성(unique key, primary key)를 가진다.

## 1) 테이블 작성시 제약 정의

<img width="405" alt="스크린샷 2021-09-16 오전 11 44 52" src="https://user-images.githubusercontent.com/81137234/133541039-d1e197cc-4b4e-4828-a37c-9916b812574e.png">

열에 대해 정의하는 제약을 열 제약이라 부른다. 복수 열에 의한 기본키 제약처럼 한 개의 제약으로 복수의 열에 제약을 설명하는 경우를 테이블 제약이라고 부른다.

<img width="402" alt="스크린샷 2021-09-16 오전 11 46 55" src="https://user-images.githubusercontent.com/81137234/133541219-bb4a208b-d280-449a-aa82-1fc5280ebb6c.png">

제약에는 이름을 붙일 수 있다. 제약에 이름을 붙이면 나중에 관리하기 쉬어지므로 가능한 이름을 붙이도록한다. 제약 이름은 `constraint` 키워드를 사용한다.

<img width="404" alt="스크린샷 2021-09-16 오후 1 13 07" src="https://user-images.githubusercontent.com/81137234/133548252-f88360d4-9a20-4ab3-bdd9-18c82ed6a502.png">

테이블 제약은 ALTER table의 add 하부 명령으로 추가할 수 있다. 다음은 기본키 제약을 추가하는 예이다. 기본키는 테이블에 하나만 설정할 수 있다. 이미 기본키가 설정되어 있는 테이블에 추가로 기본키를 작성할 수는 없다. 또 열 제약을 추가할 때와 마찬가지로 기존의 행을 검사해 추가할 제약을 위반하는 데이터가 있으면 에러가 발생한다.

<img width="404" alt="스크린샷 2021-09-16 오후 1 15 07" src="https://user-images.githubusercontent.com/81137234/133548415-f945560d-8eac-46b8-8ea1-784dd2f907b4.png">

테이블 제약은 나중에 삭제할 수도 있다. 열 제약의 경우, 제약을 추가할 때와 동일하게 열 정의를 변경한다. 다음은 앞서 추가한 c열의 NOT NULL 제약을 삭제하는 예이다.

한편, 테이블 제약은 ALTER TABLE의 DROP 하부명령으로 삭제할 수 있다. 삭제할 때는 제약명을 지정한다.

<img width="403" alt="스크린샷 2021-09-16 오후 1 18 41" src="https://user-images.githubusercontent.com/81137234/133548679-f59c6b8e-3682-4613-883c-21961b0d2320.png">

기본키는 테이블당 하나만 설정할 수 있기 때문에 굳이 제약명을 지정하지 않고도 삭제할 수 있다.

기본키로 지정할 열은 NOT NULL 제약이 설정되어 있어야 한다.
대량의 데이터에서 원하는 데이터를 찾아낼 때 키가 되는 요소르 지정해 검색하는 것이다.

<img width="409" alt="스크린샷 2021-09-16 오후 1 20 36" src="https://user-images.githubusercontent.com/81137234/133548824-6b0d4954-9fd1-43fd-9076-093ef3fd379a.png">

기본키는 테이블의 행 한 개를 특정할 수 있는 검색키이다. 기본키 제약이 설정된 테이블에서는 기본키로 검색했을 때 복수의 행이 일치하는 데이터를 작성할 수 없다. 간단히 말하면, 기본키로 설정된 열이 중복하는 데이터 값을 가지면 제약에 위반된디.

<img width="393" alt="스크린샷 2021-09-16 오후 1 27 03" src="https://user-images.githubusercontent.com/81137234/133549326-7a521d27-8d66-465f-8769-d7f52b388027.png">

insert 명령은 기본키 제약에 위반되어 P 열의 값이 중복되는 것은 입력할 수 있다.

<img width="879" alt="스크린샷 2021-09-16 오후 1 32 27" src="https://user-images.githubusercontent.com/81137234/133549908-95702bf7-be48-4ca3-875c-e5f8cc42e127.png">

explain 뒤에 확인하고 싶은 select 명령 등의 SQL 명령을 지정하면 된다. 이 SQL 명령은 실제로는 실행되지 않는다. 어떤 상태로 실행되는지 데이터베이스가 설명해줄 뿐이다.

---

<br>

# 30강 뷰 작성과 삭제

select 명령은 객체가 아니다. select 명령에 이름을 지정할 수 없고, 데이터베이스에도 등록되지 않는다. select 명령에 이름을 지정할 수도 없고 데이터베이스에 등록되지도 않는다.

데이터베이스 객체로 등록할 수 없는 select 명령을, 객체로서 이름을 붙여 관리할 수 있도록 한 것이 뷰이다. select 명령은 실행했을 때 테이블에 저장된 데이터를 결과값으로 반환한다. 따라서 뷰를 참조하면 그에 정의된 select 명령의 실행결과를 테이블처럼 사용할 수 있다.

<img width="347" alt="스크린샷 2021-09-16 오후 1 38 42" src="https://user-images.githubusercontent.com/81137234/133550328-1f83d418-0d8d-4e1e-9814-2846d4f11d2f.png">

서브쿼리 부분을 뷰 객체로 만들면 다음과 같은 select 명령이 된다.
서브쿼리 부분이 단순한 select 명령으로 되어 있지만, 실제 업무에서는 where 구로 조건을 지정하거나 GROUP BY 구로 집계하는 등 좀 더 복잡한 명령으로 이루어지는 경우가 많다. 이런 경우 서브쿼리 부분을 뷰로 대체하여 select 명령을 간략하게 표현할 수 있다. 또한 뷰를 사용함으로써 복잡한 select 명령을 데이터베이스에 등록해 두었다가 나중에 간단히 실행할 수도 있다. 즉, 자주 사용하거나 복잡한 select 명령을 뷰로 만들어 편리하게 사용할 수 있다.

뷰는 테이블처럼 취급할 수 있지만, 실체가 존재하지 않는다라는 의미로 가상 테이블이라 부르기도 한다. select 명령으로 이루어지는 뷰는 테이블처럼 데이터를 쓰거나 지울 수 있는 저장 공간을 가지지 않는다. 이 때문에 테이블 처럼 취급할 수 있다고 해도 select 명령에서만 사용하는 것이 권장된다.

## 1) 뷰 작성과 삭제

뷰는 데이터베이스 객체이기 때문에 DDL로 작성하거나 삭제한다. 작성할 때 create view를, 삭제할 때는 drop view를 사용한다.

<img width="393" alt="스크린샷 2021-09-16 오후 1 44 46" src="https://user-images.githubusercontent.com/81137234/133550867-9d44e83b-e9c6-439d-ba0f-1ee9b2d8c1b5.png">

select 명령의 구에서 지정하는 열 정보가 수집되어 자동적으로 뷰의 열로 지정된다. 반대로 열을 지정한 경우에는 select 명령의 구에서 지정한 열보다 우선된다. 다만, select 명령의 구와 같은 수의 열을 일일이 지정해야 하므로 select 명령의 모든 열을 사용할 경우에는 열을 지정하지 않는 편이 낫다. 또한 열 이외에는 정의할 수 없으며, 테이블 열을 정의할 때처럼 자료형이나 제약도 지정할 수 없다.

<img width="271" alt="스크린샷 2021-09-16 오후 1 48 44" src="https://user-images.githubusercontent.com/81137234/133551256-16275299-60ae-4f56-8cb9-b8b41ab18903.png">

뷰 삭제 경우에는 더 이상 참조할 수 없다.

select 명령은 데이터베이스의 테이블에서 행을 검색해 클라이언트로 반환하는 명령이다. 검색뿐만 아니라 order by 로 정렬하거나 group by로 집계할 수 있다. 이러한 처리는 계산능력을 필요로 하기 때문에 컴퓨터의 CPU를 사용한다.

뷰를 참조하면 뷰에 등록되어 있는 select 명령이 실행된다. 실행 결과는 일시적으로 보존되며, 뷰를 참조할 때마다 select 명령이 실행된다.

머티리얼라이즈드 뷰는 처음 참조되었을 때 데이터를 저장해둔다. 이후 다시 참조할 때 이전에 저장해 두었던 데이터를 그대로 사용한다. 일반적인 뷰처럼 매번 select 명령을 실행할 필요가 없다. 다만 뷰에 지정된 테이블의 데이터가 변경된 경우에는 select 명령을 재실행하여 데이터를 다시 저장한다. 이처럼 변경 유무를 확인하여 재실행 하는 것을 RDBMS가 자동으로 실행한다.

뷰에 지정된 테이블의 데이터가 자주 변경되지 않는 경우라면 머티리얼라이즈드 뷰를 사용하여 뷰의 약점을 보완할 수 있다.

뷰를 구성하는 select 명령은 단독으로도 실행할 수 있어야한다. 상관 서브쿼리에서 언급한 것처럼, 부모 쿼리와 어떤 식으로든 서브쿼리의 경우에는 뷰의 select 명령으로 사용할 수 없다. 대신 이 같은 뷰의 약점을 함수 테이블을 사용하여 회피할 수 있다. 함수 테이블을 결괏값으로 반환해주는 사용자 정의 함수이다. 함수에는 인수를 ㅣ쩡할 수 있기 때문에 인수의 값에 따라 where 조건을 붙여 결괏값을 바꿀 수 있다. 그에 따라 상관 서브쿼리처럼 동작할 수 있다.

<br>
